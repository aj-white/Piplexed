{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Piplexed","text":"<p>Documentation: https://aj-white.github.io/piplexed/.</p> <p>Source Code: https://github.com/aj-white/piplexed</p>"},{"location":"#overview","title":"Overview","text":"<p>Piplexed is a command line tool to identify outdated python packages, installed from PyPI, via pipx. It displays it's output as a rich printed table by default, with an alternative tree output available if desired.</p>"},{"location":"#what-is-pipx","title":"What is pipx ?","text":"<p>Pipx is a tool to help you install applications written in Python, into isolated environments with the ability to run them globally with no environment activation necessary.</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.9+</li> <li>At least one python package installed with pipx</li> </ul> <p>Windows Users</p> <p>If you experience issues with strange characters being shown, this is most likely due to Windows ability to handle utf-8 encoding. If this happens you may need to change the code page by typing <code>chcp 65001</code> or use a prompt like ohmyposh which does this for you.</p>"},{"location":"#installation","title":"Installation","text":"<p>Piplexed is designed to be installed or run via pipx.</p> <p>To install piplexed with pipx</p> <pre><code>$ pipx install piplexed\n</code></pre> <p>Or to run piplexed without installing</p> <pre><code>$ pipx run -- piplexed list --outdated\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>Show the installed package version and the latest PyPI version, excluding pre-release and dev-release versions.</p> <pre><code>$ piplexed list --outdated\n</code></pre> <p> </p> <p>Show the installed package version and the latest PyPI version, including pre-release and dev-release versions.</p> <pre><code>piplexed list --outdated --pre\n</code></pre> <p> </p> <p>Show the installed package version and python version of the virtual environment of packages installed with pipx. (Similar to the <code>pipx list</code> command, without the need to go out the internet, which the <code>pipx list</code> command does).</p> <pre><code>$ piplexed list\n</code></pre> <p> </p> <p>If you prefer there is also a tree view option.</p> <pre><code>$ piplexed list --tree\n</code></pre> <p> </p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"Command-line-options/","title":"Command Line Options","text":"<p>The commands of piplexed can been seen by running <code>piplexed --help</code></p> <p>For each each command running <code>--help</code> will show all the command line options, which are detailed below.</p> <pre><code>$ piplexed list --help\n$ piplexed version --help\n</code></pre>"},{"location":"Command-line-options/#piplexed-list","title":"piplexed list","text":"<p>List all packages installed via pipx (output in table format by default)</p> <pre><code>$ piplexed list\n</code></pre>"},{"location":"Command-line-options/#-outdated-o","title":"<code>--outdated</code> / <code>-O</code>","text":"<p>Show any packages installed via pipx that have a newer version on PyPI</p> <pre><code>$ piplexed list --outdated\n</code></pre>"},{"location":"Command-line-options/#-pre-p","title":"<code>--pre</code> / <code>P</code>","text":"<p>Include pre-release or dev-releases when determining newer versions (use in conjunction with <code>--outdated</code>)</p> <pre><code>$ piplexed list --outdated --pre\n</code></pre>"},{"location":"Command-line-options/#-tree-t","title":"<code>--tree</code> / <code>-T</code>","text":"<p>Output as a rich tree (less useful if lots of packages)</p> <pre><code>$ piplexed list --tree\n$ piplexed list --outdated --tree\n</code></pre>"},{"location":"Command-line-options/#piplexed-version","title":"piplexed version","text":"<p>Show version</p> <pre><code>$ piplexed version\n0.1.2\n</code></pre>"},{"location":"Future-development/","title":"Future Development","text":"<p>Piplexed is a project that I built for my workflow, but it may not work for everyone.</p> <p>It is only intended to work for packages that are installed from PyPI, so will not work for local packages or git/url etc.</p> <p>There are several areas I am thinking about improving:</p> <ul> <li>Highlighting when a new version is a major version increase.</li> <li>Somehow getting changelog information (if available) and providing an option to display it.</li> </ul>"},{"location":"How-piplexed-works/","title":"How piplexed works","text":"<p>Below is a brief outline of the strategies employed to make piplexed work.</p>"},{"location":"How-piplexed-works/#how-does-piplexed-find-pipx-local-virtual-environments","title":"How does piplexed find pipx local virtual environments ?","text":"<p>Piplexed uses the same paths and/or environment variables that pipx uses to determine the environment locations.</p>"},{"location":"How-piplexed-works/#how-does-piplexed-find-the-version-of-each-pipx-installed-package","title":"How does piplexed find the version of each pipx installed package ?","text":"<p>When pipx installs a package it creates a pipx_metadata.json file in the venv, which contains among other things, the installed package name, version and the python version in the venv.</p> <p>Piplexed finds and parses the pipx_metadata.json file.</p>"},{"location":"How-piplexed-works/#how-does-piplexed-determine-what-the-latest-pypi-version-is","title":"How does piplexed determine what the latest PyPI version is ?","text":"<p>It turns out that determining the latest PyPI version of a package is a surprisingly hard thing to do consistently and reliably. There are 2 APIs for PyPI the json and simple API, with the simple API now being recommended for getting release information.</p> <p>There is a python wrapper package for the simple api pypi-simple that returns a project pagre for each package containing it's version history. However there is no guarenteed order to the release versions.</p> <p>Piplexed uses the simple API for PyPI (via the pypi-simple package), which provides an HTML (or JSON) page that lists all versions of package files (sdists and wheels) that have been uploaded. Because wheels are often platform specific, there is no guarantee that a suitable wheel distribution is available. Piplexed avoids the complications of obtating platform details and python versions and just looks at the sdist versions.</p> <p>Piplexed employs the strategy recommended in PEP 700 to get the latest version, which utilises the packaging package to parse version numbers.</p> <p>Note</p> <p>Most of this info was gleaned from looking at and researching Bern\u00e1t G\u00e1bor's package pypi-changes, which also has heavily influenced this project.</p>"},{"location":"Release-notes/","title":"Release Notes","text":""},{"location":"Release-notes/#unreleased","title":"Unreleased","text":""},{"location":"Release-notes/#050","title":"0.5.0","text":"<ul> <li>\u2705 Testing for all pipx metadata versions has been added</li> <li>\ud83d\udc7d How pipx home is located updated to bring into line with pipx</li> <li>\ud83d\udc1b Handle multiple json files in pipx venv directory.</li> </ul>"},{"location":"Release-notes/#040","title":"0.4.0","text":"<ul> <li>Table is now the default option for <code>list</code> command, tree view still available via <code>--tree</code> option.</li> <li>Ignore PyPI packages whose version does not follow PEP 440.</li> </ul>"},{"location":"Release-notes/#030","title":"0.3.0","text":"<ul> <li>\ud83d\udcddMinor docs fix for shell examples</li> <li>\ud83d\udc84 Python version colour in <code>piplexed list</code> changed to a lighter green</li> </ul>"},{"location":"Release-notes/#020","title":"0.2.0","text":"<ul> <li>\ud83d\udd27 Added support for python 3.12</li> <li>\ud83d\udcdd Updated docs for windows display issues</li> <li>\u2728 Table option for CLI output</li> </ul>"},{"location":"Release-notes/#012","title":"0.1.2","text":"<ul> <li>Yet another <code>pyproject.toml</code> mishap, this time <code>python_requires</code> set to the wrong minimum version.</li> </ul>"},{"location":"Release-notes/#011","title":"0.1.1","text":""},{"location":"Release-notes/#fixed","title":"Fixed","text":"<ul> <li>Github repo link in <code>pyproject.toml</code> was wrong so links on PyPI returned a 404 error.</li> </ul>"},{"location":"Release-notes/#010","title":"0.1.0","text":""},{"location":"Release-notes/#fixed_1","title":"Fixed","text":"<ul> <li>If a non-PyPI package (for example a local wheel) is installed with pipx, a <code>NoSuchProjectError</code> results due it not being on PyPI. This has been resolved by using the pipx metadata json file to determine if the package was installed from a non-PyPi source and not request it's details from PyPI</li> <li>Various linitng and mypy errors have been squashed.</li> </ul>"},{"location":"Release-notes/#added","title":"Added","text":"<ul> <li>A user cache directory has been added using platformdirs to cache PyPI responses</li> <li>Added nox as test and lint runner</li> <li>Added github actions for linting and tests</li> </ul>"},{"location":"Release-notes/#changed","title":"Changed","text":"<ul> <li><code>remove_expired_responses()</code> is being depracted in <code>requests-cache</code> this has been replaced with <code>cache.delete(expired=True)</code></li> </ul>"},{"location":"Release-notes/#002","title":"0.0.2","text":"<p>\ud83d\udd3c Upgrade pypi-simple to 1.1.0 for PEP 700 support.</p>"},{"location":"Why-piplexed/","title":"Why piplexed ?","text":""},{"location":"Why-piplexed/#short-answer","title":"Short answer","text":"<p>The name piplexed is a play on words, it contains the letters for pipx and I was also mildly perplexed trying to find a simpler way to identify outdated pipx installed packages, only to discover it didn't exist. Put the two together and well.... you get the idea (naming things is hard after all!)</p>"},{"location":"Why-piplexed/#long-answer","title":"Long answer","text":"<p>Pipx is a really useful tool, essentially any python package that has a console script entry point can be installed in its own isolated environment, but still be run directly from the command line without requiring any virtual environment activation or polluting the main python install.</p> <p>When building libraries and applications I use a fairly consistent set of tools.</p> <ul> <li>virtualenv - I prefer this to the standard library venv module as it is faster at environoment creation, installs wheel by default and gives you an up to date version of pip.</li> <li>black - consistent code formatting</li> <li>mypy - static type checking</li> <li>ruff - code linting</li> <li>hatch - Starting projects, bumping versions and building packages</li> </ul> <p>For personal projects, rather than having to install these packages in every project (taking up time and disk space!), they can be installed once, in a single isolated location, and used in each project thanks to pipx.</p> <p>Tip</p> <p>one caveat with mypy is that you have to pass it the <code>--python-executable</code> flag with the path to python executable in the environment you want to run it on, otherwise it can't find helpful things like stub files.</p> <p>However, over time, packages get updated, either to introduce new features or fix bugs and security issues. Pipx provides the following commands to update a specfic package or update all installed packages.</p> <pre><code>pipx upgrade PACKAGE_NAME\npipx upgrade-all\n</code></pre> <p>Upgrading a single package, requires knowing there is an updated version on PyPI already or the <code>upgrade-all</code> command can be run periodically to always get the latest version(s). This runs the risk of a newer version (especially if it is a new major version) either breaking the workflow (due to API changes) or behaving in unexpected ways (due to changed behaviour).</p> <p>In order to avoid this I would run <code>pipx list</code>, then manually check PyPI for a newer version. If there was one I'd check the release notes to see if there were any breaking changes and if all looked okay, update the package.</p> <p>Having grown tired of manually checking PyPI for new versions, I wanted a more efficient solution.</p> <p>Depenendcy management has always been a little bit tricky in python and there are lots of tools to manage dependencies in a virtual environment e.g. poetry, pip-tools.</p> <p>Even using just pip you can get a list of outdated packages in an environment with the command:</p> <pre><code>python -m pip list --outdated\n</code></pre> <p>This will display any dependency that has a newer version on PyPI, including all package sub-dependencies.</p> <p>All these tools work on a per environment basis but I was looking for a tool or way to show outdated packages installed with pipx, which involves multiple environments.</p> <p>The <code>pipx list</code> command shows all the packages installed with pipx (excluding dependencies) and their versions. However there is no <code>outdated</code> option like pip.</p>"},{"location":"Why-piplexed/#are-there-existing-solutions","title":"Are There Existing Solutions ?","text":"<p>There are a couple of issues on pipx's github page that have been open for a couple of years now looking at this feature but as yet no progress:</p> <ul> <li>#149 - Feature request: Option to list available upgrades without performing them</li> <li>#464 - Check for latest version before running with pipx run</li> </ul> <p>A search of PyPI also showed no existing solutions, so I decided to build something to solve the problem.</p>"},{"location":"Why-piplexed/#why-not-submit-a-pr-instead","title":"Why not submit a PR instead ?","text":"<p>You may ask why not fix one of the above issues ?</p> <p>That's a perfectly valid question. The truth is I currently don't feel like I have the skills to provide a robust enough solution that would work across multiple OS to satisfy the requirements of a package as widely used as pipx. This project is an opportunity for me to develop (hack together) a solution that works for me, it is not intended to be a universal solution for all.</p>"}]}